/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.asgteach.familytree.persontimeline;

import com.asgteach.familytree.model.Event;
import com.asgteach.familytree.model.FamilyTreeManager;
import com.asgteach.familytree.model.Person;
import com.asgteach.familytree.utilities.PersonCapabilityNode;
import java.awt.BorderLayout;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.Collection;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.application.Platform;
import javafx.embed.swing.JFXPanel;
import javafx.fxml.FXMLLoader;
import javafx.fxml.JavaFXBuilderFactory;
import javafx.scene.Parent;
import javafx.scene.Scene;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.LifecycleManager;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.LookupEvent;
import org.openide.util.LookupListener;
import org.openide.util.NbBundle.Messages;
import org.openide.util.Utilities;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
    dtd = "-//com.asgteach.familytree.persontimeline//PersonTimeLine//EN",
autostore = false)
@TopComponent.Description(
    preferredID = "PersonTimeLineTopComponent",
iconBase = "com/asgteach/familytree/persontimeline/TimelineIcon.png",
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "output", openAtStartup = true)
@ActionID(category = "Window", id = "com.asgteach.familytree.persontimeline.PersonTimeLineTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
    displayName = "#CTL_PersonTimeLineAction",
preferredID = "PersonTimeLineTopComponent")
@Messages({
    "CTL_PersonTimeLineAction=PersonTimeLine",
    "# {0} - person", "CTL_PersonTimeLineTopComponent={0} TimeLine",
    "HINT_PersonTimeLineTopComponent=This is a PersonTimeLine window"
})
public final class PersonTimeLineTopComponent extends TopComponent implements
        LookupListener, PropertyChangeListener {

    private Lookup.Result<PersonCapabilityNode> result;
    private static JFXPanel fxPanel;
    private Person person = null;
    private PersonTimeLineController controller;
    private FamilyTreeManager ftm;
    private static final Logger logger = Logger.getLogger(PersonTimeLineTopComponent.class.getName());

    public PersonTimeLineTopComponent() {
        initComponents();
        setName(Bundle.CTL_PersonTimeLineTopComponent(""));
        setToolTipText(Bundle.HINT_PersonTimeLineTopComponent());

        setLayout(new BorderLayout());
        //Enable the Print action for the TopComponent:
        //putClientProperty("print.printable", true);
        init();
    }

    public void init() {
        fxPanel = new JFXPanel();
        add(fxPanel, BorderLayout.CENTER);
        Platform.setImplicitExit(false);
        Platform.runLater(this::createScene);
    }

    private void createScene() {
        try {
            URL location = getClass().getResource("PersonTimeLine.fxml");
            FXMLLoader fxmlLoader = new FXMLLoader();
            fxmlLoader.setLocation(location);
            fxmlLoader.setBuilderFactory(new JavaFXBuilderFactory());

            Parent root = (Parent) fxmlLoader.load(location.openStream());
            Scene scene = new Scene(root);
            fxPanel.setScene(scene);
            String cssURL = "timeLineStyleSheet.css";
            String css = this.getClass().getResource(cssURL).toExternalForm();
            scene.getStylesheets().add(css);
            controller = (PersonTimeLineController) fxmlLoader.getController();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened() {
        result = Utilities.actionsGlobalContext().lookupResult(PersonCapabilityNode.class);
        result.addLookupListener(this);
        this.ftm = Lookup.getDefault().lookup(FamilyTreeManager.class);
        if (ftm == null) {
            logger.log(Level.SEVERE, "Cannot get FamilyTreeManager object");
            LifecycleManager.getDefault().exit();
        }
        ftm.addPropertyChangeListener(this);
        setName(Bundle.CTL_PersonTimeLineTopComponent(""));
    }

    @Override
    public void componentClosed() {
        result.removeLookupListener(this);
        ftm.removePropertyChangeListener(this);
        person = null;
        Platform.runLater(controller::clearPanel);
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void resultChanged(LookupEvent ev) {
        Collection<? extends PersonCapabilityNode> nodes = result.allInstances();
        // only get the selection if there is one
        // otherwise leave the selection unchanged!

        // If you want the selection window to clear
        // when the user clicks on a non-node thingy,
        // then remove the test for isEmpty
        if (nodes.size() == 1) {
            // display if only 1 Person node is selected
            for (PersonCapabilityNode node : nodes) {
                Person newperson = node.getLookup().lookup(Person.class);

                if (newperson != null && !newperson.equals(person)) {
                    person = newperson;
                    WindowManager.getDefault().invokeWhenUIReady(() -> {
                        setName(Bundle.CTL_PersonTimeLineTopComponent(person.toString()));
                    });
                    Platform.runLater(() -> {
                        controller.updateAll(person);
                    });
                }
            }
        }
    }

    @Override
    public void propertyChange(PropertyChangeEvent pce) {
        if (person == null) {
            return;
        }
        // detect if the displayed Person has been removed
        switch (pce.getPropertyName()) {
            case FamilyTreeManager.PROP_PERSON_DESTROYED:
                if (pce.getOldValue() != null
                        && Objects.equals(((Person) pce.getOldValue()).getId(), person.getId())) {
                    logger.log(Level.FINER, "detected Person Destroyed for {0}", person);
                    person = null;
                    WindowManager.getDefault().invokeWhenUIReady(() -> {
                        setName(Bundle.CTL_PersonTimeLineTopComponent(""));
                    });
                    Platform.runLater(controller::clearPanel);
                }   break;
            case FamilyTreeManager.PROP_EVENT_DESTROYED:
            case FamilyTreeManager.PROP_EVENT_ADDED:
            case FamilyTreeManager.PROP_EVENT_UPDATED:
                // Does this event belong to our Person?
                if (pce.getOldValue() != null
                        && Objects.equals(((Event) pce.getOldValue()).getPerson().getId(), person.getId())) {
                    logger.log(Level.FINER, "Event added, updated, or deleted for {0}", person);
                    Platform.runLater(() -> {
                        controller.updateEvents(person);
                    });
                }   break;
            case FamilyTreeManager.PROP_PERSON_UPDATED:
                // Is this our Person?
                if (pce.getOldValue() != null
                        && Objects.equals(((Person) pce.getOldValue()).getId(), person.getId())) {
                    logger.log(Level.FINER, "Person updated for {0}", person);
                    person = (Person) pce.getOldValue();
                    WindowManager.getDefault().invokeWhenUIReady(() -> {
                        setName(Bundle.CTL_PersonTimeLineTopComponent(person.toString()));
                    });
                    Platform.runLater(() -> {
                        controller.updatePerson(person);
                    });
            }   break;
        }
    }
}
