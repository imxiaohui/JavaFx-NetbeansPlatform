/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.asgteach.familytree.personfiletype;

import java.awt.BorderLayout;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.concurrent.CountDownLatch;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.application.Platform;
import javafx.embed.swing.JFXPanel;
import javafx.fxml.FXMLLoader;
import javafx.fxml.JavaFXBuilderFactory;
import javafx.scene.Parent;
import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import org.netbeans.core.spi.multiview.CloseOperationState;
import org.netbeans.core.spi.multiview.MultiViewElement;
import org.netbeans.core.spi.multiview.MultiViewElementCallback;
import org.openide.awt.UndoRedo;
import org.openide.cookies.EditorCookie;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.openide.xml.XMLUtil;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

@MultiViewElement.Registration(
        displayName = "#LBL_FamilyTree_VISUALFX",
        iconBase = "com/asgteach/familytree/personfiletype/FamilyTreeIcon.png",
        mimeType = "text/familytree+xml",
        persistenceType = TopComponent.PERSISTENCE_NEVER,
        preferredID = "FamilyTreeVisualFX",
        position = 2000
)
@Messages("LBL_FamilyTree_VISUALFX=VisualFX")
public final class FamilyTreeVisualFXElement extends JPanel implements MultiViewElement {

    private final FamilyTreeDataObject ftDataObject;
    private final JToolBar toolbar = new JToolBar();
    private transient MultiViewElementCallback callback;
    private EditorCookie editCookie = null;
    private Document doc = null;
    private static JFXPanel fxPanel;
    private FamilyTreeFXController controller;
    private static final Logger logger = Logger.getLogger(FamilyTreeVisualFXElement.class.getName());

    public FamilyTreeVisualFXElement(Lookup lkp) {
        ftDataObject = lkp.lookup(FamilyTreeDataObject.class);
        assert ftDataObject != null;
        initComponents();
        setLayout(new BorderLayout());
        init();
    }

    private void init() {
        fxPanel = new JFXPanel();
        add(fxPanel, BorderLayout.CENTER);
        Platform.setImplicitExit(false);
        // need to wait for this to complete!
        // so that we can safely add ourselves as a
        // property change listener
        final CountDownLatch latch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                createScene();
            } finally {
                latch.countDown();
            }
        });
        try {
            latch.await();
        } catch (InterruptedException ex) {
            logger.log(Level.WARNING, null, ex);
        }
    }

    private void createScene() {
        try {
            URL location = getClass().getResource("FamilyTreeFX.fxml");
            FXMLLoader fxmlLoader = new FXMLLoader();
            fxmlLoader.setLocation(location);
            fxmlLoader.setBuilderFactory(new JavaFXBuilderFactory());

            Parent root = (Parent) fxmlLoader.load(location.openStream());
            javafx.scene.Scene scene = new javafx.scene.Scene(root);
            fxPanel.setScene(scene);
            controller = (FamilyTreeFXController) fxmlLoader.getController();
        } catch (IOException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    @Override
    public String getName() {
        return "FamilyTreeVisualFXElement";
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public JComponent getVisualRepresentation() {
        return this;
    }

    @Override
    public JComponent getToolbarRepresentation() {
        return toolbar;
    }

    @Override
    public Action[] getActions() {
        return new Action[0];
    }

    @Override
    public Lookup getLookup() {
        return ftDataObject.getLookup();
    }

    @Override
    public void componentOpened() {
    }

    @Override
    public void componentClosed() {
    }

    @Override
    public void componentShowing() {
        logger.log(Level.INFO, "Component Showing");
        editCookie = ftDataObject.getLookup().lookup(EditorCookie.class);
        if (editCookie != null) {
            try (InputStream is = ((org.openide.text.CloneableEditorSupport) editCookie).getInputStream()) {
                //Use the NetBeans org.openide.xml.XMLUtil class to create a org.w3c.dom.Document:
                doc = XMLUtil.parse(new InputSource(is), true, true, null, null);
                final CountDownLatch latch = new CountDownLatch(1);
                Platform.runLater(() -> {
                    try {
                        controller.refresh(doc);
                    } finally {
                        latch.countDown();
                    }
                });
                try {
                    latch.await();
                    // wait for refresh() to complete before 
                    // initiating the fade-in
                    Platform.runLater(() -> controller.doFadeIn());
                } catch (InterruptedException ex) {
                    logger.log(Level.WARNING, null, ex);
                }

            } catch (IOException | SAXException ex) {
                Exceptions.printStackTrace(ex);
            }
        }
    }

    @Override
    public void componentHidden() {
        Platform.runLater(() -> controller.clear());
    }

    @Override
    public void componentActivated() {
    }

    @Override
    public void componentDeactivated() {
    }

    @Override
    public UndoRedo getUndoRedo() {
        return UndoRedo.NONE;
    }

    @Override
    public void setMultiViewCallback(MultiViewElementCallback callback
    ) {
        this.callback = callback;
    }

    @Override
    public CloseOperationState canCloseElement() {
        return CloseOperationState.STATE_OK;
    }

}
